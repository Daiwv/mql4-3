//+--------------------------------------------------------------------------------------------------------------------------------------------------+
//|                                                                                                                  ZH_Global_Chart_Variable_Lib.mq4|
//|                                                                                                                  Copyright © Zhunko              |
//|04.09.2008 - 10.09.2008                                                                                           MF ZHUNKO vadim@zhunko.ru       |
//+--------------------------------------------------------------------------------------------------------------------------------------------------+
//| Библиотека предназначена для работы с глобальными графическими переменными.                                                                      |
//| Глобальная графическая переменная (графический объект), видимая для программ только одного окна.                                                 |
//| ВНИМАНИЕ!!! Количество записываемых знаков с учётом разделителей во всех функциях не может превышать 62-х.                                       |
//+--------------------------------------------------------------------------------------------------------------------------------------------------+
//| 1. Функция возвращает числовое значение глобальной графической переменной.                                                                       |
//| 2. Функция возвращает строковое значение глобальной графической переменной.                                                                      |
//| 3. Функция устанавливает новое числовое значения глобальной графической переменной.                                                              |
//| 4. Функция устанавливает новое строковое значения глобальной графической переменной.                                                             |
//+--- Функции с графическими массивами. ------------------------------------------------------------------------------------------------------------+
//| 5. Функция меняет значение выбранной ячейки в графическом массиве.                                                                               |
//| 6. Функция читает выбранную ячейку графического массива с данными двойной точности.                                                              |
//| 7. Функция возвращает число элементов в указанном измерении графического массива.                                                                |
//| 8. Функция меняет размер указанного измерения графического массива.                                                                              |
//+--- Функции с графическими файлами. --------------------------------------------------------------------------------------------------------------+
//| 9. Функция записывает одномерный целочисленный массив в графический файл.                                                                        |
//|10. Функция записывает двумерный целочисленный массив в графический файл.                                                                         |
//|11. Функция записывает одномерный массив с данными двойной точности в графический файл.                                                           |
//|12. Функция заполняет значениями двойной точности глобальный графический двумерный массив.                                                        |
//|13. Функция читает указанное число элементов из графического файла в одномерный целочисленный массив.                                             |
//|14. Функция читает все элементы из графического файла в двумерный целочисленный массив.                                                           |
//|15. Функция читает указанное число элементов из графического файла в одномерный массив данных двойной точности.                                   |
//|16. Функция читает все элементы из графического файла в двумерный целочисленный массив данных двойной точности.                                   |
//+--- Служебные функции с глобальными графическими переменными, массивами и файлами. ---------------------------------------------------------------+
//|17. Функция контроля наличия глобальной графической переменной.                                                                                   |
//|18. Функция удаления глобальной графической переменной.                                                                                           |
//|19. Функция возвращает имя глобальной графической переменной по порядковому номеру в списке глобальных графических переменных.                    |
//|20. Функция возвращает общее количество глобальных графических переменных.                                                                        |
//|21. Функция удаляет глобальные графические переменные.                                                                                            |
//|22. Функция меняет название глобальной графической переменной.                                                                                    |
//+--------------------------------------------------------------------------------------------------------------------------------------------------+
#property copyright "Copyright © 2008 Zhunko"
#property link      "vadim@zhunko.ru"
#property library
//жжжж Функции с глобальными графическими переменными. жжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжж
// 1. Функция возвращает числовое значение глобальной графической переменной.=========================================================================
// Возвращает числове значение существующей глобальной графической переменной.
double GlobalChartVariableGetDouble (string& Name) // Имя глобальной графической переменной.
 {
  return (StrToDouble (ObjectDescription (Name)));
 }
//====================================================================================================================================================
// 2. Функция возвращает строковое значение глобальной графической переменной.========================================================================
// Возвращает строкове значение существующей глобальной графической переменной.
string GlobalChartVariableGetStr (string& Name) // Имя глобальной графической переменной.
 {
  return (ObjectDescription (Name));
 }
//====================================================================================================================================================
// 3. Функция устанавливает новое числовое значения глобальной графической переменной.================================================================
// Устанавливает новое числовое значение существующей глобальной графической переменной.
// Если переменная не существует, создаётся новая глобальная графическая переменная.
// В случае успеха функция возвращает значение TRUE, иначе FALSE.
bool GlobalChartVariableSetDouble (string& Name,      // Имя глобальной графической переменной.
                                   double& Value,     // Числовое значение.
                                   int&    Precision) // Точность записи в знаках после запятой.
 {
  int i;
  //----
  if (Name == "" || Name == "Label")
   {
    Print ("Ошибка в функции \"GlobalChartVariableSetDouble()\". Недопустимое название графической переменной.");
    Comment ("Ошибка в функции \"GlobalChartVariableSetDouble()\".\nНедопустимое название графической переменной.");
    return (false);
   }
  if (StringLen (Name) > 62)
   {
    Print ("Ошибка в функции \"GlobalChartVariableSetDouble()\". Слишком длинное имя переменной. Количество знаков в имени должно быть менее 62 знаков.");
    Comment ("Ошибка в функции \"GlobalChartVariableSetDouble()\".\nСлишком длинное имя переменной.\nКоличество знаков в имени должно быть менее 62 знаков.");
    return (false);
   }
  // Создаём объект.
  if (ObjectCreate (Name, OBJ_LABEL, 0, 0, 0, 0, 0) == true)
   {
    if (ObjectFind ("ListGlobalGraphicVariable_0") == -1) // Если списка глобальных графических переменных нет, то создаём его и вносим имя переменной.
     {
      ObjectCreate  ("ListGlobalGraphicVariable_0", OBJ_LABEL, 0, 0, 0, 0, 0);
      ObjectSet     ("ListGlobalGraphicVariable_0", OBJPROP_TIMEFRAMES, EMPTY);
      ObjectSetText ("ListGlobalGraphicVariable_0", Name, 10, "Areal", EMPTY);
     }
    else // Если список глобальных графических переменных есть, то дополняем его.
     {
      for (i = 0; i < 100; i++)                          // Цикл по списку.
       {// Ищем первый отсутствующий объект или пустую запись.
        if (ObjectFind ("ListGlobalGraphicVariable_" + i) == -1 || ObjectDescription ("ListGlobalGraphicVariable_" + i) == "" || ObjectDescription ("ListGlobalGraphicVariable_" + i) == "Label")
         {// Если нашли номер отсутствующего объекта, создаём его и записываем в нём имя переменной. 
          ObjectCreate  ("ListGlobalGraphicVariable_" + i, OBJ_LABEL, 0, 0, 0, 0, 0);
          ObjectSet     ("ListGlobalGraphicVariable_" + i, OBJPROP_TIMEFRAMES, EMPTY);
          ObjectSetText ("ListGlobalGraphicVariable_" + i, Name, 10, "Areal", EMPTY);
          break;                                        // Выходим из цикла.
         } 
       }
     }
   }
  ObjectSet (Name, OBJPROP_TIMEFRAMES, EMPTY);
  return (ObjectSetText (Name, DoubleToStr (Value, Precision), 10, "Areal", EMPTY));
 }
//====================================================================================================================================================
// 4. Функция устанавливает новое строковое значения глобальной графической переменной.===============================================================
// Устанавливает новое строковое значение существующей глобальной графической переменной.
// Если переменная не существует, создаётся новая глобальная графическая переменная.
// В случае успеха функция возвращает значение TRUE, иначе FALSE.
bool GlobalChartVariableSetStr (string& Name,  // Имя глобальной графической переменной.
                                string& Value) // Строковое значение.
 {
  int i;
  //----
  if (Name == "" || Name == "Label")
   {
    Print ("Ошибка в функции \"GlobalChartVariableSetStr()\". Недопустимое название графической переменной.");
    Comment ("Ошибка в функции \"GlobalChartVariableSetStr()\".\nНедопустимое название графической переменной.");
    return (false);
   }
  if (StringLen (Name) > 62)
   {
    Print ("Ошибка в функции \"GlobalChartVariableSetStr()\". Слишком длинное имя переменной. Количество знаков в имени должно быть менее 62 знаков.");
    Comment ("Ошибка в функции \"GlobalChartVariableSetStr()\".\nСлишком длинное имя переменной.\nКоличество знаков в имени должно быть менее 62 знаков.");
    return (false);
   }
  // Создаём объект.
  if (ObjectCreate (Name, OBJ_LABEL, 0, 0, 0, 0, 0) == true)
   {
    if (ObjectFind ("ListGlobalGraphicVariable_0") == -1) // Если списка глобальных графических переменных нет, то создаём его и вносим имя переменной.
     {
      ObjectCreate  ("ListGlobalGraphicVariable_0", OBJ_LABEL, 0, 0, 0, 0, 0);
      ObjectSet     ("ListGlobalGraphicVariable_0", OBJPROP_TIMEFRAMES, EMPTY);
      ObjectSetText ("ListGlobalGraphicVariable_0", Name, 10, "Areal", EMPTY);
     }
    else // Если список глобальных графических переменных есть, то дополняем его.
     {
      for (i = 0; i < 100; i++)                          // Цикл по списку.
       {// Ищем первый отсутствующий объект или пустую запись.
        if (ObjectFind ("ListGlobalGraphicVariable_" + i) == -1 || ObjectDescription ("ListGlobalGraphicVariable_" + i) == "" || ObjectDescription ("ListGlobalGraphicVariable_" + i) == "Label")
         {// Если нашли номер отсутствующего объекта, создаём его и записываем в нём имя переменной. 
          ObjectCreate  ("ListGlobalGraphicVariable_" + i, OBJ_LABEL, 0, 0, 0, 0, 0);
          ObjectSet     ("ListGlobalGraphicVariable_" + i, OBJPROP_TIMEFRAMES, EMPTY);
          ObjectSetText ("ListGlobalGraphicVariable_" + i, Name, 10, "Areal", EMPTY);
          break;                                        // Выходим из цикла.
         } 
       }
     }
   }
  ObjectSet    (Name, OBJPROP_TIMEFRAMES, EMPTY);
  return (ObjectSetText (Name, Value, 10, "Areal", EMPTY));
 }
//====================================================================================================================================================
//жжжж Функции с графическими массивами. жжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжж
// 5. Функция меняет значение выбранной ячейки в графическом массиве.=================================================================================
// Если графического массива не существует, создаётся новый графический массив. Можно записывать целые и двойной точности числа.
// Выбор производится параметром "Precision". В случае успеха функция возвращает значение TRUE, иначе FALSE.
bool ChartArraySet (string& Name,      // Имя графического массива.
                    double& Value,     // Числовое значение для внесения изменений в массиве.
                    int&    Precision, // Точность записи в знаках после запятой.
                    int&    Size0,     // Количество элементов первого измерения.
                    int&    Size1,     // Количество элементов второго измерения.
                    int&    Cell0,     // Номер ячейки первого измерения.
                    int&    Cell1)     // Номер ячейки второго измерения.
 {
  int    i, j, k;
  int    EndStr1;         // Номер позиции конца первой строки до числа.
  int    Length;          // Длина всего текста.
  int    StartStr2;       // Номер позиции начала второй строки после числа.
  string Text = "";       // Массив в строковом виде. Текст.
  string TextSymbol = ""; // Строковый символ.
  //----
  if (Name == "" || Name == "Label")
   {
    Print ("Ошибка в функции \"ChartArraySet()\". Недопустимое название графического массива.");
    Comment ("Ошибка в функции \"ChartArraySet()\".\nНедопустимое название графического массива.");
    return (false);
   }
  if (StringLen (Name) > 62)
   {
    Print ("Ошибка в функции \"ChartArraySet()\". Слишком длинное имя массива. Количество знаков в имени должно быть менее 62 знаков.");
    Comment ("Ошибка в функции \"ChartArraySet()\".\nСлишком длинное имя массива.\nКоличество знаков в имени должно быть менее 62 знаков.");
    return (false);
   }
  if ((2 * Size0 * Size1 - 1) > 62)
   {
    Print ("Ошибка в функции \"ChartArraySet()\". Попытка создать массив с количеством знаков более 62 с учётом разделителей.");
    Comment ("Ошибка в функции \"ChartArraySet()\".\nПопытка создать массив с количеством знаков более 62 с учётом разделителей.");
    return (false);
   }
  if (Cell0 >= Size0)
   {
    Print ("Ошибка в функции \"ChartArraySet()\". Номер ячейки первой размерности превышает количество элементов.");
    Comment ("Ошибка в функции \"ChartArraySet()\".\nНомер ячейки первой размерности превышает количество элементов.");
    return (false);
   }
  if (Cell1 >= Size1)
   {
    Print ("Ошибка в функции \"ChartArraySet()\". Номер ячейки второй размерности превышает количество элементов.");
    Comment ("Ошибка в функции \"ChartArraySet()\".\nНомер ячейки второй размерности превышает количество элементов.");
    return (false);
   }
  if (ObjectFind (Name) == -1)                           // Если графического массива не существует, создаём новый с одной заполненной ячейкой. Все остальные заполняем нулями.
   {
    for (i = 0; i < Size0; i++)                          // Цикл первого измерения.
     {
      for (j = 0; j < Size1; j++)                        // Цикл второго измерения.
       {
        k++;                                             // Счётчик всех элементов.
        if (i == Cell0 && j == Cell1) Text = Text + DoubleToStr (Value, Precision); // Если адрес совпал, заносим новое значение.
        else Text = Text + "0";                          // Во все остальные ячейки заносим нули.
        if (j != (Size1 - 1)) Text = Text + ";";         // Устанавливаем разделители второго измерения.
        else if (k != Size0 * Size1) Text = Text + "|";  // Устанавливаем разделители первого измерения.
       }
     }
   }
  else
   {// Если графический массив существует, сначала проверяем на соответствие размеров измерений.
    Text = "|" + ObjectDescription (Name) + ";";         // Весь текст.
    Length = StringLen (Text);                           // Длина текста.
    for (i = 0, j = 0, k = 0; i < Length; i++)           // Цикл по элементам текста.
     {
      TextSymbol = StringSubstr (Text, i, 1);            // Символ.
      if (TextSymbol == "|") j++;                        // Проверяем на разделитель первого измерения.
      if (TextSymbol == ";" || TextSymbol == "|") k++;   // Проверяем на разделитель второго измерения.
     }
    k--;
    if (j != Size0) // Контроль размерности массива и заявленного параметра размерности в первом измерении.
     {
      Print ("Ошибка в функции \"ChartArraySet()\". Размер существующего массива в первом измерении не соответствует заявленному параметру \"Size0\".");
      Comment ("Ошибка в функции \"ChartArraySet()\".\nРазмер существующего массива в первом измерении не соответствует заявленному параметру \"Size0\".");
      return (false);
     }
    if (k / j != Size1) // Контроль размерности массива и заявленного параметра размерности во втором измерении.
     {
      Print ("Ошибка в функции \"ChartArraySet()\". Размер существующего массива во втором измерении не соответствует заявленному параметру \"Size0\".");
      Comment ("Ошибка в функции \"ChartArraySet()\".\nРазмер существующего массива во втором измерении не соответствует заявленному параметру \"Size1\".");
      return (false);
     }
    // Ищим номера позиций до и после числа.
    for (i = 0, k = 0; i < Length; i++)                  // Цикл по элементам текста.
     {
      TextSymbol = StringSubstr (Text, i, 1);            // Текущий символ.
      if (TextSymbol == ";" || TextSymbol == "|")        // Ищим разделители.
       {
        if (k == (Cell0 * Size1 + Cell1))                // Если совпал номер разделителя с номером искомой позиции.
         {
          EndStr1 = i;                                   // Номер позиции конца первой строки до числа включая разделитель.
          break;                                         // Выходим из цикла.
         }
        k++;                                             // Номер разделителя.
       }
     }
    for (i++; i < Length; i++)                           // Продолжаем цикл по элементам текста.
     {
      TextSymbol = StringSubstr (Text, i, 1);            // Текущий символ.
      if (TextSymbol == ";" || TextSymbol == "|")        // Следующий разделитель.
       {
        StartStr2 = i;                                   // Номер позиции начала второй строки после числа включая разделитель.
        break;                                           // Выходим из цикла.
       }
     }
    // Синтезируем новую строку.
    Text = StringSubstr (Text, 0, EndStr1 + 1) + DoubleToStr (Value, Precision) + StringSubstr (Text, StartStr2, 0);
    Text = StringSubstr (Text, 1, StringLen (Text) - 2); // Убираем первый и последний служебные разделители.
    if (StringLen (Text) > 62)
     {
      Print ("Ошибка синтеза строки в функции \"ChartArraySet()\". Попытка записать в массив количество знаков более 62 с учётом разделителей.");
      Comment ("Ошибка синтеза строки в функции \"ChartArraySet()\". Попытка записать в массив количество знаков более 62 с учётом разделителей.");
      return (false);
     }
   }
  // Создаём объект.
  if (ObjectCreate (Name, OBJ_LABEL, 0, 0, 0, 0, 0) == true)
   {
    if (ObjectFind ("ListGlobalGraphicVariable_0") == -1) // Если списка глобальных графических переменных нет, то создаём его и вносим имя переменной.
     {
      ObjectCreate  ("ListGlobalGraphicVariable_0", OBJ_LABEL, 0, 0, 0, 0, 0);
      ObjectSet     ("ListGlobalGraphicVariable_0", OBJPROP_TIMEFRAMES, EMPTY);
      ObjectSetText ("ListGlobalGraphicVariable_0", Name, 10, "Areal", EMPTY);
     }
    else // Если список глобальных графических переменных есть, то дополняем его.
     {
      for (i = 0; i < 100; i++)                           // Цикл по списку.
       {// Ищем первый отсутствующий объект или пустую запись.
        if (ObjectFind ("ListGlobalGraphicVariable_" + i) == -1 || ObjectDescription ("ListGlobalGraphicVariable_" + i) == "" || ObjectDescription ("ListGlobalGraphicVariable_" + i) == "Label")
         {// Если нашли номер отсутствующего объекта, создаём его и записываем в нём имя переменной. 
          ObjectCreate  ("ListGlobalGraphicVariable_" + i, OBJ_LABEL, 0, 0, 0, 0, 0);
          ObjectSet     ("ListGlobalGraphicVariable_" + i, OBJPROP_TIMEFRAMES, EMPTY);
          ObjectSetText ("ListGlobalGraphicVariable_" + i, Name, 10, "Areal", EMPTY);
          break;                                          // Выходим из цикла.
         } 
       }
     }
   }
  ObjectSet (Name, OBJPROP_TIMEFRAMES, EMPTY);
  return (ObjectSetText (Name, Text, 10, "Areal", EMPTY));
 }
//====================================================================================================================================================
// 6. Функция читает выбранную ячейку графического массива с данными двойной точности.================================================================
// Функция возвращает значение выбранной ячейки или "-1" в случае ошибки. Если массив одномерный, то параметр "Cell0" должен быть равен нулю.
double ChartArrayGet (string& Name,  // Имя графического массива.
                      int&    Cell0, // Номер ячейки первого измерения.
                      int&    Cell1) // Номер ячейки второго измерения.
 {
  int    i, j, k;
  int    Length;          // Длина всего текста.
  int    LengthNumber;    // Длина извлекаемого числа.
  int    Start;           // Стартовая позиция для извлечения числа.
  string Text = "|" + ObjectDescription (Name) + ";";
  string TextSymbol = ""; // Строковый символ.
  //----
  Length = StringLen (Text);
  for (i = 0; i < Length; i++)
   {
    TextSymbol = StringSubstr (Text, i, 1);                 // Текущий символ.
    if (TextSymbol == "|")                                  // Если нашли в строке разделитель первой размерности или массив одномерный.
     {
      if (j == Cell0)                                       // Если номер разделителя совпадает с номером ячейки в первой размерности.
       {
        for (; i < Length; i++)                             // Продолжаем начатый основной цикл.
         {
          TextSymbol = StringSubstr (Text, i, 1);           // Текущий символ.
          if (TextSymbol == ";")                            // Если нашли в строке разделитель второй размерности.
           {
            if (k == Cell1)                                 // Если номер разделителя совпадает с номером ячейки во второй размерности.
             {
              LengthNumber = i;                             // Запоминаем позицию конца числа. Разделитель ";" находится после искомого числа.
              for (i--; i >= 0; i--)                        // Продолжаем начатый основной цикл в обратную сторону к началу строки.
               {
                TextSymbol = StringSubstr (Text, i, 1);     // Текущий символ.
                if (TextSymbol == ";" || TextSymbol == "|") // По следующему разделителю определяем длину числа.
                 {
                  Start = i + 1;
                  LengthNumber = LengthNumber - Start;
                  break;
                 }
               }
              return (StrToDouble (StringSubstr (Text, Start, LengthNumber)));
             }
            k++;
           }
         }
       }
      j++;
     }
   }
  return (-1);
 }
//====================================================================================================================================================
// 7. Функция возвращает число элементов в указанном измерении графического массива.==================================================================
// Возвращает число элементов в указанном измерении графического массива, в противном случае "-1".
int ChartArrayRange (string& Name,       // Имя графического массива.
                     int&    RangeIndex) // Индекс измерения.
 {
  int    i, j, k;                                     // Номер позиции начала второй строки после числа.
  int    Length;                                      // Длина всего текста.
  string Text = "|" + ObjectDescription (Name) + ";"; // Массив в строковом виде. Текст.
  string TextSymbol = "";                             // Строковый символ.
  //----
  Length = StringLen (Text);                          // Длина текста.
  for (i = 0, j = 0, k = 0; i < Length; i++)          // Цикл по элементам текста.
   {
    TextSymbol = StringSubstr (Text, i, 1);           // Символ.
    if (TextSymbol == "|") j++;                       // Проверяем на разделитель первого измерения.
    if (TextSymbol == ";" || TextSymbol == "|") k++;  // Проверяем на разделитель первого и второго измерений.
   }
  if (RangeIndex == 0) return (j);                    // Возвращаем количество элементов в первом измерении.
  if (RangeIndex == 1) return ((k - 1) / j);          // Возвращаем количество элементов во втором измерении.
  return (-1);
 }
//====================================================================================================================================================
// 8. Функция меняет размер указанного измерения графического массива.================================================================================
// При успешном выполнении функция возвращает количество всех элементов, содержащихся в массиве после изменения размера,
// в противном случае возвращает -1, и массив не меняет размеры.
int ChartArrayResize (string& Name,       // Имя графического массива.
                      int&    RangeIndex, // Индекс измерения.
                      int&    NewSize)    // Новый размер.
 {
  int    i, j, k, l;                                  // Номер позиции начала второй строки после числа.
  int    Length;                                      // Длина всего текста.
  int    Size0;                                       // Размер первого измерения.
  int    Size1;                                       // Размер второго измерения.
  string StringSize1 = "";                            // Строка дополняемого второго измерения.
  string Text = "|" + ObjectDescription (Name) + ";"; // Массив в строковом виде. Текст. Добавляем служебные символы.
  string TextSymbol = "";                             // Строковый символ.
  // Массивы.
  string ArraySize0[];                                // Технический массив для строк второго измерения.
  //----Контроль входных параметров.------------------------------------------------------------------------------------------------------------------
  if (RangeIndex < 0 || 1 < RangeIndex)               // Контроль параметра "Индекс измерения".
   {
    Print ("Ошибка в функции \"ChartArrayResize()\". Индекс измерения выходит за пределы возможных значений. RangeIndex = ", RangeIndex);
    Comment ("Ошибка в функции \"ChartArrayResize()\".\nИндекс измерения выходит за пределы возможных значений.\nRangeIndex = ", RangeIndex);
    return (-1);
   }
  if (NewSize < 0)                                    // Контроль параметра "Новый размер".
   {
    Print ("Ошибка в функции \"ChartArrayResize()\". Новый размер выходит за пределы возможных значений. NewSize = ", NewSize);
    Comment ("Ошибка в функции \"ChartArrayResize()\".\nНовый размер выходит за пределы возможных значений.\nNewSize = ", NewSize);
    return (-1);
   }
  // Вычисляем размер существующего массива.
  Length = StringLen (Text);                          // Длина текста.
  for (i = 0, j = 0, k = 0; i < Length; i++)          // Цикл по элементам текста.
   {
    TextSymbol = StringSubstr (Text, i, 1);           // Символ.
    if (TextSymbol == "|") j++;                       // Проверяем на разделитель первого измерения.
    if (TextSymbol == ";" || TextSymbol == "|") k++;  // Проверяем на разделитель первого и второго измерений.
   }
  Size0 = j;                                          // Размер первого измерения.
  Size1 = (k - 1) / j;                                // Размер второго измерения.
  //----Если требуется изменить первое измерение.-----------------------------------------------------------------------------------------------------
  if (RangeIndex == 0)
   {
    if (NewSize < Size0)                              // Если новый размер меньше, чем существующий.
     {
      for (i = 0, j = -1; i < Length; i++)            // Цикл по элементам текста.
       {
        TextSymbol = StringSubstr (Text, i, 1);       // Символ.
        if (TextSymbol == "|") j++;                   // Проверяем на разделитель первого измерения. Считаем разделители.
        // Если совпал новый размер с текущим разделителем. Обрезаем строку и меняем свойства объекта. Возвращаем новое количество элементов.
        if (j == NewSize) if (ObjectSetText (Name, StringSubstr (Text, 1, i - 1), 10, "Areal", EMPTY) == true) return (j * Size1);
       }
     }
    if (NewSize == Size0) return (k - 1);             // Если новый размер равен существующему.
    if (NewSize > Size0)                              // Если новый размер больше, чем существующий.
     {
      StringSize1 = "|";                              // Инициализируем переменную строки дополняемого второго измерения.
      for (i = 0; i < Size1; i++)                     // Синтезируем всю строку одного нового элемента первого измерения.
       {
        if (i == (Size1 - 1)) StringSize1 = StringSize1 + "0"; // После последнего элемента разделитель не ставим.
        else StringSize1 = StringSize1 + "0;";
       }
      Text = ObjectDescription (Name);
      for (i = 0; i < (NewSize - Size0); i++) Text = Text + StringSize1;
      // Контроль на длину записи массива с новым размером.
      if (StringLen (Text) > 62)
       {
        Print ("Ошибка в функции \"ChartArrayResize()\". Попытка создать массив с количеством знаков более 62 с учётом разделителей.");
        Comment ("Ошибка в функции \"ChartArrayResize()\".\nПопытка создать массив с количеством знаков более 62 с учётом разделителей.");
        return (-1);
       }
      if (ObjectSetText (Name, Text, 10, "Areal", EMPTY) == true) return ((Size0 + i) * Size1); // Возвращаем новое количество элементов.
     }
   }
  //----Если требуется изменить второе измерение.-----------------------------------------------------------------------------------------------------
  if (RangeIndex == 1)
   {
    if (NewSize < Size1)                                              // Если новый размер меньше, чем существующий.
     {
      ArrayResize (ArraySize0, Size0);                                // Изменяем размер технического массива по размер графического массива в первом измерении.
      for (i = 0; i < Size0; i++) ArraySize0[i] = "";                 // Инициализируем технический массив пустыми строками.
      for (i = 0, j = -1, l = 0; i < Length; i++)                     // Цикл по элементам текста.
       {
        TextSymbol = StringSubstr (Text, i, 1);                       // Символ.
        if (TextSymbol == "|")                                        // Проверяем на разделитель первого измерения. 
         {
          j++;                                                        // Считаем разделители первого измерения.
          k = 0;                                                      // Обнуляем счётчик разделителей второго измерения.
         }
        if (TextSymbol == ";" || TextSymbol == "|")                   // Проверяем на разделитель первого и второго измерений.
         {
          k++;                                                        // Считаем разделители второго измерения.
          if (k <= NewSize) l++;                                      // Считаем все новые элементы.
         }
        if (k <= NewSize) ArraySize0[j] = ArraySize0[j] + TextSymbol; // Синтезируем строку первого измерения в пределах нового размера второго измерения.
       }
      // В первой ячейки технического массива синтезируем всю новую строку для нового размера графического массива.
      for (i = 1; i < Size0; i++) ArraySize0[0] = ArraySize0[0] + ArraySize0[i];
      // Отрезаем служебный символ спереди. Меняем свойства объекта. Возвращаем новое количество элементов.
      if (ObjectSetText (Name, StringSubstr (ArraySize0[0], 1, 0), 10, "Areal", EMPTY) == true) return (l);
     }
    if (NewSize == Size1) return (k - 1);                             // Если новый размер равен существующему.
    if (NewSize > Size1)                                              // Если новый размер больше, чем существующий.
     {
      ArrayResize (ArraySize0, Size0);                                // Изменяем размер технического массива по размер графического массива в первом измерении.
      for (i = 0; i < Size0; i++) ArraySize0[i] = "";                 // Инициализируем технический массив пустыми строками.
      Text = "|" + ObjectDescription (Name);                          // Массив в строковом виде. Текст. Добавляем служебные символы.
      Length = StringLen (Text);                                      // Длина текста.
      for (i = 0, j = -1, k = 0; i < Length; i++)                     // Цикл по элементам текста.
       {
        TextSymbol = StringSubstr (Text, i, 1);                       // Символ.
        if (TextSymbol == "|") j++;                                   // Проверяем на разделитель первого измерения.  Считаем разделители первого измерения.
        if (TextSymbol == ";" || TextSymbol == "|") k++;              // Проверяем на разделитель первого и второго измерений.
        ArraySize0[j] = ArraySize0[j] + TextSymbol;                   // Синтезируем строку первого измерения в пределах нового размера второго измерения.
       }
      StringSize1 = ";";                                              // Инициализируем переменную строки дополняемого второго измерения.
      for (i = 0, l = 0; i < (NewSize - Size1); i++, l++)             // Синтезируем часть строки нового элемента первого измерения.
       {
        if (i == (NewSize - Size1 - 1)) StringSize1 = StringSize1 + "0"; // После последнего элемента разделитель не ставим.
        else StringSize1 = StringSize1 + "0;";
       }
      // Синтезируем всю строку одного элемента первого измерения.
      for (i = 0; i < Size0; i++) ArraySize0[i] = ArraySize0[i] + StringSize1;
      // В первой ячейки технического массива синтезируем всю новую строку для нового размера графического массива.
      for (i = 1; i < Size0; i++) ArraySize0[0] = ArraySize0[0] + ArraySize0[i];
      // Отрезаем служебный символ спереди.
      Text = StringSubstr (ArraySize0[0], 1, 0);
      if (StringLen (Text) > 62)
       {
        Print ("Ошибка в функции \"ChartArrayResize()\". Попытка создать массив с количеством знаков более 62 с учётом разделителей.");
        Comment ("Ошибка в функции \"ChartArrayResize()\".\nПопытка создать массив с количеством знаков более 62 с учётом разделителей.");
        return (-1);
       }
      // Меняем свойства объекта. Возвращаем новое количество элементов.
      if (ObjectSetText (Name, Text, 10, "Areal", EMPTY) == true) return (k + l * Size0);
     }
   }
  return (-1);
 }
//====================================================================================================================================================
//жжжж Функции с графическими файлами. жжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжж
// 9. Функция записывает одномерный целочисленный массив в графический файл.==========================================================================
// Если глобального графического файла не существует, создаётся новый графический файл.
// В случае успеха функция возвращает значение количество записанных знаков. В противном случае "-1".
int FileChartWriteArray1Int (string& Name,    // Имя графического файла.
                             int&    Array[], // Массив для записи.
                             int&    Start,   // Начальный индекс в массиве (номер первого записываемого элемента).
                             int&    Count)   // Количество записываемых элементов.
 {
  int i;
  int Length;
  string Text = "";
  // Контроль входных параметров.
  if (Name == "" || Name == "Label") // Контроль имени.
   {
    Print ("Ошибка в функции \"FileChartWriteArray1Int()\". Недопустимое название графического файла.");
    Comment ("Ошибка в функции \"FileChartWriteArray1Int()\".\nНедопустимое название графического файла.");
    return (-1);
   }
  if (StringLen (Name) > 62) // Контроль длины имени.
   {
    Print ("Ошибка в функции \"FileChartWriteArray1Int()\". Слишком длинное имя графического файла. Количество знаков в имени должно быть менее 62 знаков.");
    Comment ("Ошибка в функции \"FileChartWriteArray1Int()\".\nСлишком длинное имя графического файла.\nКоличество знаков в имени должно быть менее 62 знаков.");
    return (-1);
   }
  // Синтез строки для записи.
  for (i = Start; i < (Start + Count); i++)
   {
    Text = Text + DoubleToStr (Array[i], 0) + ";";
    Length = StringLen (Text) - 1;
    if (Length > 62)
     {
      Print ("Ошибка в функции \"FileChartWriteArray1Int()\". Попытка записать в массив количество знаков более 62 с учётом разделителей.");
      Comment ("Ошибка в функции \"FileChartWriteArray1Int()\". Попытка записать в массив количество знаков более 62 с учётом разделителей.");
      return (-1);
     }
   }
  Text = StringSubstr (Text, 0, Length);
  // Создаём объект.
  if (ObjectCreate (Name, OBJ_LABEL, 0, 0, 0, 0, 0) == true)
   {
    if (ObjectFind ("ListGlobalGraphicVariable_0") == -1) // Если списка глобальных графических переменных нет, то создаём его и вносим имя переменной.
     {
      ObjectCreate  ("ListGlobalGraphicVariable_0", OBJ_LABEL, 0, 0, 0, 0, 0);
      ObjectSet     ("ListGlobalGraphicVariable_0", OBJPROP_TIMEFRAMES, EMPTY);
      ObjectSetText ("ListGlobalGraphicVariable_0", Name, 10, "Areal", EMPTY);
     }
    else // Если список глобальных графических переменных есть, то дополняем его.
     {
      for (i = 0; i < 100; i++)                          // Цикл по списку.
       {// Ищем первый отсутствующий объект или пустую запись.
        if (ObjectFind ("ListGlobalGraphicVariable_" + i) == -1 || ObjectDescription ("ListGlobalGraphicVariable_" + i) == "" || ObjectDescription ("ListGlobalGraphicVariable_" + i) == "Label")
         {// Если нашли номер отсутствующего объекта, создаём его и записываем в нём имя переменной. 
          ObjectCreate  ("ListGlobalGraphicVariable_" + i, OBJ_LABEL, 0, 0, 0, 0, 0);
          ObjectSet     ("ListGlobalGraphicVariable_" + i, OBJPROP_TIMEFRAMES, EMPTY);
          ObjectSetText ("ListGlobalGraphicVariable_" + i, Name, 10, "Areal", EMPTY);
          break;                                        // Выходим из цикла.
         } 
       }
     }
   }
  ObjectSet (Name, OBJPROP_TIMEFRAMES, EMPTY);
  if (ObjectSetText (Name, Text, 10, "Areal", EMPTY) == true) return (Length);
  return (-1);
 }
//====================================================================================================================================================
//10. Функция записывает двумерный целочисленный массив в графический файл.===========================================================================
// Если глобального графического файла не существует, создаётся новый графический файл.
// В случае успеха функция возвращает значение количество записанных знаков. В противном случае "-1".
int FileChartWriteArray2Int (string& Name,      // Имя графического файла.
                             int&    Array[][]) // Массив для записи.
 {
  int    Size0 = ArrayRange (Array, 0);
  int    Size1 = ArrayRange (Array, 1);
  int    i, j;
  int    Length;
  string Text = "";
  // Контроль входных параметров.
  if (Name == "" || Name == "Label") // Контроль имени.
   {
    Print ("Ошибка в функции \"FileChartWriteArray2Int()\". Недопустимое название графического файла.");
    Comment ("Ошибка в функции \"FileChartWriteArray2Int()\".\nНедопустимое название графического файла.");
    return (-1);
   }
  if (StringLen (Name) > 62) // Контроль длины имени.
   {
    Print ("Ошибка в функции \"FileChartWriteArray2Int()\". Слишком длинное имя файла. Количество знаков в имени должно быть менее 62 знаков.");
    Comment ("Ошибка в функции \"FileChartWriteArray2Int()\".\nСлишком длинное имя файла.\nКоличество знаков в имени должно быть менее 62 знаков.");
    return (-1);
   }
  // Синтез строки для записи.
  for (i = 0; i < Size0; i++)
   {
    for (j = 0; j < Size1; j++)
     {
      if (j == (Size1 - 1)) Text = Text + DoubleToStr (Array[i][j], 0) + "|";
      else Text = Text + DoubleToStr (Array[i][j], 0) + ";";
      Length = StringLen (Text) - 1;
      if (Length > 62)
       {
        Print ("Ошибка в функции \"FileChartWriteArray2Int()\". Попытка записать в массив количество знаков более 62 с учётом разделителей.");
        Comment ("Ошибка в функции \"FileChartWriteArray2Int()\". Попытка записать в массив количество знаков более 62 с учётом разделителей.");
        return (-1);
       }
     }
   }
  Text = StringSubstr (Text, 0, Length);
  // Создаём объект.
  if (ObjectCreate (Name, OBJ_LABEL, 0, 0, 0, 0, 0) == true)
   {
    if (ObjectFind ("ListGlobalGraphicVariable_0") == -1) // Если списка глобальных графических переменных нет, то создаём его и вносим имя переменной.
     {
      ObjectCreate  ("ListGlobalGraphicVariable_0", OBJ_LABEL, 0, 0, 0, 0, 0);
      ObjectSet     ("ListGlobalGraphicVariable_0", OBJPROP_TIMEFRAMES, EMPTY);
      ObjectSetText ("ListGlobalGraphicVariable_0", Name, 10, "Areal", EMPTY);
     }
    else // Если список глобальных графических переменных есть, то дополняем его.
     {
      for (i = 0; i < 100; i++)                          // Цикл по списку.
       {// Ищем первый отсутствующий объект или пустую запись.
        if (ObjectFind ("ListGlobalGraphicVariable_" + i) == -1 || ObjectDescription ("ListGlobalGraphicVariable_" + i) == "" || ObjectDescription ("ListGlobalGraphicVariable_" + i) == "Label")
         {// Если нашли номер отсутствующего объекта, создаём его и записываем в нём имя переменной. 
          ObjectCreate  ("ListGlobalGraphicVariable_" + i, OBJ_LABEL, 0, 0, 0, 0, 0);
          ObjectSet     ("ListGlobalGraphicVariable_" + i, OBJPROP_TIMEFRAMES, EMPTY);
          ObjectSetText ("ListGlobalGraphicVariable_" + i, Name, 10, "Areal", EMPTY);
          break;                                        // Выходим из цикла.
         } 
       }
     }
   }
  ObjectSet (Name, OBJPROP_TIMEFRAMES, EMPTY);
  if (ObjectSetText (Name, Text, 10, "Areal", EMPTY) == true) return (Length);
  return (-1);
 }
//====================================================================================================================================================
//11. Функция записывает одномерный массив с данными двойной точности в графический файл.=============================================================
// Если глобального графического массива не существует, создаётся новая глобальный графический одномерный массив.
// В случае успеха функция возвращает значение количество записанных знаков. В противном случае "-1".
int FileChartWriteArray1Double (string& Name,      // Имя графического файла.
                                double& Array[],   // Массив для записи.
                                int&    Precision, // Точность записи в знаках после запятой.
                                int&    Start,     // Начальный индекс в массиве (номер первого записываемого элемента).
                                int&    Count)     // Количество записываемых элементов.
 {
  int i;
  int Length;
  string Text = "";
  // Контроль входных параметров.
  if (Name == "" || Name == "Label") // Контроль имени.
   {
    Print ("Ошибка в функции \"FileChartWriteArray1Double()\". Недопустимое название графического файла.");
    Comment ("Ошибка в функции \"FileChartWriteArray1Double()\".\nНедопустимое название графического файла.");
    return (-1);
   }
  if (StringLen (Name) > 62) // Контроль длины имени.
   {
    Print ("Ошибка в функции \"FileChartWriteArray1Double()\". Слишком длинное имя файла. Количество знаков в имени должно быть менее 62 знаков.");
    Comment ("Ошибка в функции \"FileChartWriteArray1Double()\".\nСлишком длинное имя файла.\nКоличество знаков в имени должно быть менее 62 знаков.");
    return (-1);
   }
  // Синтез строки для записи.
  for (i = Start; i < (Start + Count); i++)
   {
    Text = Text + DoubleToStr (Array[i], Precision) + ";";
    Length = StringLen (Text) - 1;
    if (Length > 62)
     {
      Print ("Ошибка в функции \"FileChartWriteArray1Double()\". Попытка записать в массив количество знаков более 62 с учётом разделителей.");
      Comment ("Ошибка в функции \"FileChartWriteArray1Double()\". Попытка записать в массив количество знаков более 62 с учётом разделителей.");
      return (-1);
     }
   }
  Text = StringSubstr (Text, 0, Length);
  // Создаём объект.
  if (ObjectCreate (Name, OBJ_LABEL, 0, 0, 0, 0, 0) == true)
   {
    if (ObjectFind ("ListGlobalGraphicVariable_0") == -1) // Если списка глобальных графических переменных нет, то создаём его и вносим имя переменной.
     {
      ObjectCreate  ("ListGlobalGraphicVariable_0", OBJ_LABEL, 0, 0, 0, 0, 0);
      ObjectSet     ("ListGlobalGraphicVariable_0", OBJPROP_TIMEFRAMES, EMPTY);
      ObjectSetText ("ListGlobalGraphicVariable_0", Name, 10, "Areal", EMPTY);
     }
    else // Если список глобальных графических переменных есть, то дополняем его.
     {
      for (i = 0; i < 100; i++)                          // Цикл по списку.
       {// Ищем первый отсутствующий объект или пустую запись.
        if (ObjectFind ("ListGlobalGraphicVariable_" + i) == -1 || ObjectDescription ("ListGlobalGraphicVariable_" + i) == "" || ObjectDescription ("ListGlobalGraphicVariable_" + i) == "Label")
         {// Если нашли номер отсутствующего объекта, создаём его и записываем в нём имя переменной. 
          ObjectCreate  ("ListGlobalGraphicVariable_" + i, OBJ_LABEL, 0, 0, 0, 0, 0);
          ObjectSet     ("ListGlobalGraphicVariable_" + i, OBJPROP_TIMEFRAMES, EMPTY);
          ObjectSetText ("ListGlobalGraphicVariable_" + i, Name, 10, "Areal", EMPTY);
          break;                                        // Выходим из цикла.
         } 
       }
     }
   }
  ObjectSet (Name, OBJPROP_TIMEFRAMES, EMPTY);
  if (ObjectSetText (Name, Text, 10, "Areal", EMPTY) == true) return (Length);
  return (-1);
 }
//====================================================================================================================================================
//12. Функция заполняет значениями двойной точности глобальный графический двумерный массив.==========================================================
// Заполняет новыми элементами существующего глобального графического массива.
// Если глобального графического массива не существует, создаётся новая глобальный графический одномерный массив.
// В случае успеха функция возвращает значение количество записанных знаков. В противном случае "-1".
int FileChartWriteArray2Double (string& Name,      // Имя графического файла.
                                double& Array[][], // Массив для записи.
                                int&    Precision) // Точность записи в знаках после запятой.
 {
  int    Size0 = ArrayRange (Array, 0);
  int    Size1 = ArrayRange (Array, 1);
  int    i, j;
  int    Length;
  string Text = "";
  // Контроль входных параметров.
  if (Name == "" || Name == "Label") // Контроль имени.
   {
    Print ("Ошибка в функции \"FileChartWriteArray2Double()\". Недопустимое название графического файла.");
    Comment ("Ошибка в функции \"FileChartWriteArray2Double()\".\nНедопустимое название графического файла.");
    return (-1);
   }
  if (StringLen (Name) > 62) // Контроль длины имени.
   {
    Print ("Ошибка в функции \"FileChartWriteArray2Double()\". Слишком длинное имя файла. Количество знаков в имени должно быть менее 62 знаков.");
    Comment ("Ошибка в функции \"FileChartWriteArray2Double()\".\nСлишком длинное имя файла.\nКоличество знаков в имени должно быть менее 62 знаков.");
    return (-1);
   }
  // Синтез строки для записи.
  for (i = 0; i < Size0; i++)
   {
    for (j = 0; j < Size1; j++)
     {
      if (j == (Size1 - 1)) Text = Text + DoubleToStr (Array[i][j], Precision) + "|";
      else Text = Text + DoubleToStr (Array[i][j], Precision) + ";";
      Length = StringLen (Text) - 1;
      if (Length > 62)
       {
        Print ("Ошибка в функции \"FileChartWriteArray2Double()\". Попытка записать в массив количество знаков более 62 с учётом разделителей.");
        Comment ("Ошибка в функции \"FileChartWriteArray2Double()\". Попытка записать в массив количество знаков более 62 с учётом разделителей.");
        return (-1);
       }
     }
   }
  Text = StringSubstr (Text, 0, Length);
  // Создаём объект.
  if (ObjectCreate (Name, OBJ_LABEL, 0, 0, 0, 0, 0) == true)
   {
    if (ObjectFind ("ListGlobalGraphicVariable_0") == -1) // Если списка глобальных графических переменных нет, то создаём его и вносим имя переменной.
     {
      ObjectCreate  ("ListGlobalGraphicVariable_0", OBJ_LABEL, 0, 0, 0, 0, 0);
      ObjectSet     ("ListGlobalGraphicVariable_0", OBJPROP_TIMEFRAMES, EMPTY);
      ObjectSetText ("ListGlobalGraphicVariable_0", Name, 10, "Areal", EMPTY);
     }
    else // Если список глобальных графических переменных есть, то дополняем его.
     {
      for (i = 0; i < 100; i++)                          // Цикл по списку.
       {// Ищем первый отсутствующий объект или пустую запись.
        if (ObjectFind ("ListGlobalGraphicVariable_" + i) == -1 || ObjectDescription ("ListGlobalGraphicVariable_" + i) == "" || ObjectDescription ("ListGlobalGraphicVariable_" + i) == "Label")
         {// Если нашли номер отсутствующего объекта, создаём его и записываем в нём имя переменной. 
          ObjectCreate  ("ListGlobalGraphicVariable_" + i, OBJ_LABEL, 0, 0, 0, 0, 0);
          ObjectSet     ("ListGlobalGraphicVariable_" + i, OBJPROP_TIMEFRAMES, EMPTY);
          ObjectSetText ("ListGlobalGraphicVariable_" + i, Name, 10, "Areal", EMPTY);
          break;                                        // Выходим из цикла.
         } 
       }
     }
   }
  ObjectSet (Name, OBJPROP_TIMEFRAMES, EMPTY);
  if (ObjectSetText (Name, Text, 10, "Areal", EMPTY) == true) return (Length);
  return (-1);
 }
//====================================================================================================================================================
//13. Функция читает указанное число элементов из графического файла в одномерный целочисленный массив.===============================================
// Перед чтением данных массив должен быть достаточного размера.
// Функция возвращает количество фактически прочитанных элементов.
int FileChartReadArray1Int (string& Name,    // Имя графического файла.
                            int&    Array[], // Массив, куда данные будут загружены.
                            int&    Start,   // Стартовая позиция для записи в массив.
                            int&    Count)   // Количество элементов для чтения.
 {
  int    i;
  int    j = 0;
  int    Length;
  string Text = ObjectDescription (Name) + ";";
  string TextNumber = ""; // Преобразуемое число в строковом виде.
  string TextSymbol = ""; // Строковый символ.
  //----
  Length = StringLen (Text);
  for (i = 0; i < Length; i++)
   {
    TextSymbol = StringSubstr (Text, i, 1);
    if (TextSymbol == ";")
     {
      if (Count == j) break;
      Array[Start + j] = StrToInteger (TextNumber);
      TextNumber = ""; // Инициализируем заново.
      TextSymbol = ""; // Инициализируем заново.
      j++;
     }
    else TextNumber = TextNumber + TextSymbol;
   }
  return (j);
 }
//====================================================================================================================================================
//14. Функция читает все элементы из графического файла в двумерный целочисленный массив.=============================================================
// Перед чтением данных массив должен быть достаточного размера во втором измерении.
// Если файл записан без разделителя "|", как одномерный массив, то он будет прочитан согласно размера принимающего массива.
// Размер массива меньший, чем расстановка разделителей, приводит к ошибкам чтения. Массив заполняется не правильно.
// Функция возвращает количество фактически прочитанных элементов.
int FileChartReadArray2Int (string& Name,       // Имя графического файла.
                            int&    Array[][])  // Массив, куда данные будут загружены.
 {
  int    Size0 = ArrayRange (Array, 0);         // Размер первого измерения.
  int    Size1 = ArrayRange (Array, 1);         // Размер второго измерения.
  int    i;                                     // Номер позиции в строке.
  int    j = 0;                                 // Номер ячейки первого измерения.
  int    k = 0;                                 // Номер ячейки второго измерения.
  int    AmountElement = 0;                     // Количество элементов.
  int    Length;                                // Длина строки.
  string Text = ObjectDescription (Name) + ";"; // Вся строка.
  string TextNumber = "";                       // Преобразуемое число в строковом виде.
  string TextSymbol = "";                       // Строковый символ.
  //----
  Length = StringLen (Text);                    // Длина текстовой строки.
  for (i = 0; i < Length; i++)                  // Цикл по элементам текстовой строки.
   {
    TextSymbol = StringSubstr (Text, i, 1);     // Выделяем символ.
    if (TextSymbol == ";" || TextSymbol == "|" || k == Size1) // Если нашли раздеоитель.
     {
      Array[j][k] = StrToInteger (TextNumber);  // Кладём в массив найденное число.
      k++;                                      // Увеличивает значение счётчика разделителей второй размерности.
      if (TextSymbol == "|" || k == Size1)      // Если разделитель первой размерности или счётчик второй размерности совпал с размером второй размерности.
       {
        j++;                                    // Увеличивает значение счётчика разделителей первой размерности.
        k = 0;                                  // Обнуляем счётчик разделителей второй размерности.
       }
      AmountElement++;                          // Счётчик количества элементов.
      if (j >= Size0) break;                    // Выходим из цикла, если счётчик первой размерности равен количеству элементов первой размерности.
      TextNumber = "";                          // Инициализируем заново.
      TextSymbol = "";                          // Инициализируем заново.
     }
    else TextNumber = TextNumber + TextSymbol;  // Синтезируем число.
   }
  return (AmountElement);
 }
//====================================================================================================================================================
//15. Функция читает указанное число элементов из графического файла в одномерный массив данных двойной точности.=====================================
// Перед чтением данных массив должен быть достаточного размера.
// Функция возвращает количество фактически прочитанных элементов.
int FileChartReadArray1Double (string& Name,    // Имя графического файла.
                               double& Array[], // Массив, куда данные будут загружены.
                               int&    Start,   // Стартовая позиция для записи в массив.
                               int&    Count)   // Количество элементов для чтения.
 {
  int    i;
  int    j = 0;
  int    Length;
  string Text = ObjectDescription (Name) + ";";
  string TextNumber = ""; // Преобразуемое число в строковом виде.
  string TextSymbol = ""; // Строковый символ.
  //----
  Length = StringLen (Text);
  for (i = 0; i < Length; i++)
   {
    TextSymbol = StringSubstr (Text, i, 1);
    if (TextSymbol == ";")
     {
      if (Count == j) break;
      Array[Start + j] = StrToInteger (TextNumber);
      TextNumber = ""; // Инициализируем заново.
      TextSymbol = ""; // Инициализируем заново.
      j++;
     }
    else TextNumber = TextNumber + TextSymbol;
   }
  return (j);
 }
//====================================================================================================================================================
//16. Функция читает все элементы из графического файла в двумерный целочисленный массив данных двойной точности.=====================================
// Перед чтением данных массив должен быть достаточного размера во втором измерении.
// Если файл записан без разделителя "|", как одномерный массив, то он будет прочитан согласно размера массива.
// Размер массива меньший, чем расстановка разделителей, приводит к ошибкам чтения. Массив заполняется не правильно.
// Функция возвращает количество фактически прочитанных элементов.
int FileChartReadArray2double (string& Name,      // Имя графического файла.
                               double& Array[][]) // Массив, куда данные будут загружены.
 {
  int    Size0 = ArrayRange (Array, 0);         // Размер первой размерности.
  int    Size1 = ArrayRange (Array, 1);         // Размер второй размерности.
  int    i;                                     // Номер позиции в строке.
  int    j = 0;                                 // Номер ячейки первой размерности.
  int    k = 0;                                 // Номер ячейки второй размерности.
  int    AmountElement = 0;                     // Количество элементов.
  int    Length;                                // Длина строки.
  string Text = ObjectDescription (Name) + ";"; // Вся строка.
  string TextNumber = "";                       // Преобразуемое число в строковом виде.
  string TextSymbol = "";                       // Строковый символ.
  //----
  Length = StringLen (Text);
  for (i = 0; i < Length; i++)
   {
    TextSymbol = StringSubstr (Text, i, 1);
    if (TextSymbol == ";" || TextSymbol == "|" || k == Size1)
     {
      Array[j][k] = StrToInteger (TextNumber);
      k++;
      if (TextSymbol == "|" || Size1 == k)
       {
        j++;
        k = 0;
       }
      AmountElement++;
      if (j >= Size0) break;
      TextNumber = ""; // Инициализируем заново.
      TextSymbol = ""; // Инициализируем заново.
     }
    else TextNumber = TextNumber + TextSymbol;
   }
  return (AmountElement);
 }
//====================================================================================================================================================
//жжжж Служебные функции с глобальными графическими переменными, массивами и файлами. жжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжж
//17. Функция контроля наличия глобальной графической переменной.=====================================================================================
// Возвращает значение TRUE, если глобальная графическая переменная существует, иначе возвращает FALSE.
bool GlobalChartVariableCheck (string& Name) // Имя глобальной графической переменной.
 {
  if (ObjectFind (Name) == -1) return (false);
  else return (true);
 }
//====================================================================================================================================================
//18. Функция удаления глобальной графической переменной.=============================================================================================
// Удаление глобальной графической переменной с указанным именем.
// При успешном удалении функция возвращает TRUE, иначе FALSE.
bool GlobalChartVariableDel (string& Name) // Имя глобальной графической переменной.
 {
  int i;
  //----
  for (i = 0; i < 100; i++) // Цикл по списку переменных.
   {// Если нашли удаляемую переменную.
    if (ObjectDescription ("ListGlobalGraphicVariable_" + i) == Name)
     {
      for (; i < 100; i++)  // Продолжаем начатый цикл по списку переменных. Сортировка.
       {
        if (ObjectFind ("ListGlobalGraphicVariable_" + i) == -1 || ObjectDescription ("ListGlobalGraphicVariable_" + i) == "")
         {// Удаляем последние пустые строки в списке графических переменных.
          for (; ObjectDescription ("ListGlobalGraphicVariable_" + i) == "" || ObjectDescription ("ListGlobalGraphicVariable_" + i) == "Label"; i--) ObjectDelete ("ListGlobalGraphicVariable_" + i);
          // Выходим из цикла, завершаем функцию удалением графической переменной, если следующего объекта нет или он не имеет описания.
          return (ObjectDelete (Name));
         }
        // Переносим следующие записи на освободившееся место.
        ObjectSetText ("ListGlobalGraphicVariable_" + i, ObjectDescription (StringConcatenate("ListGlobalGraphicVariable_", i + 1)), 10, "Areal", EMPTY);
       }
     }
   }
  return (ObjectDelete (Name));
 }
//====================================================================================================================================================
//19. Функция возвращает имя глобальной графической переменной по порядковому номеру в списке глобальных графических переменных.======================
// Количество глобальных графических переменных не может быть больше 100. Первый индекс равен нулю. Последний индекс равен 99.
// Если под искомым индексом нет глобальной графической переменной, то функция вернёт пустую строку.
string GlobalChartVariableName (int& Index) // Порядковый номер в списке глобальных переменных. Должен быть большим или равным 0 и меньшим, чем GlobalChartVariablesTotal().
 {
  return (ObjectDescription ("ListGlobalGraphicVariable_" + Index));
 }
//====================================================================================================================================================
//20. Функция возвращает общее количество глобальных графических переменных.==========================================================================
// В случае ошибки возвращает "-1".
int GlobalChartVariablesTotal()
 {
  int    i;
  string Name;
  //----
  for (i = 0; i < 100; i++)
   {
    Name = "ListGlobalGraphicVariable_" + i;
    if (ObjectFind (Name) == -1 || ObjectDescription (Name) == "" || ObjectDescription (Name) == "Label") return (i);
   }
  return (-1);
 }
//====================================================================================================================================================
//21. Функция удаляет глобальные графические переменные.==============================================================================================
// Удаляет глобальные графические переменные. Если префикс для имени не задан, то удаляются все глобальные графические переменные.
// В противном случае удаляются только те глобальные графические переменные, имена которых начинаются на указанный префикс.
// Функция возвращает количество удаленных глобальных графических переменных в противном случае возвращает "-1".
int GlobalChartVariablesDeleteAll (string& PrefixName) // Префикс имени удаляемых глобальных переменных.
 {
  int AmountDelete; // Количество удалённых глобальных графических переменных.
  int i, j;
  int Length;       // Длина строки.
  //----
  if (PrefixName == "")       // Если префикс не задан, то удаляем все глобальные графические переменные.
   {
    for (i = 0; i < 100; i++) // Цикл по списку глобальных графических переменных.
     {
      if (ObjectFind ("ListGlobalGraphicVariable_" + i) == -1) return (i); // Завершаем функцию, если следующей записи нет.
      ObjectDelete (ObjectDescription ("ListGlobalGraphicVariable_" + i)); // Удаляем глобальную графическую переменную.
      ObjectDelete ("ListGlobalGraphicVariable_" + i);                     // Удаляем часть списка глобальных графических переменных.
     }
   }
  else // Если префикс задан, то удаляем по маске.
   {// Удаляем найденные графические переменные и обнуляем записи о них в списке.
    Length = StringLen (PrefixName);
    for (i = 0; i < 100; i++) // Цикл по списку глобальных графических переменных.
     {
      if (StringSubstr (ObjectDescription ("ListGlobalGraphicVariable_" + i), 0, Length) == PrefixName)
       {
        AmountDelete++;                                                               // Счётчик удалённых глобальных графических переменных.
        ObjectDelete (ObjectDescription ("ListGlobalGraphicVariable_" + i));          // Удаляем глобальную графическую переменную.
        ObjectSetText ("ListGlobalGraphicVariable_" + i, "", 10, "Areal", EMPTY);     // Удаляем имя из списка.
       }
     }
    // Сортировка. Записи сдвигаем в начало на свободные места.
    for (i = 0; i < 100 && ObjectFind ("ListGlobalGraphicVariable_" + j) != -1; i++)  // Цикл по списку глобальных графических переменных. Выходим из цикла, если следующего объекта (записи) нет.
     {
      if (ObjectDescription ("ListGlobalGraphicVariable_" + i) == "" || ObjectDescription ("ListGlobalGraphicVariable_" + i) == "Label") // Если нашли пустую позицию.
       {
        j = i;                                                                        // Номер первой пустой позиции в списке.
        // Продолжаем начатый цикл по списку переменных. Выходим из цикла, если следующего объекта (записи) нет.
        for (j++; j < 100 && ObjectFind ("ListGlobalGraphicVariable_" + j) != -1; j++)
         {// Ищем следующую занятую строку.
          if (ObjectDescription ("ListGlobalGraphicVariable_" + j) != "" && ObjectDescription ("ListGlobalGraphicVariable_" + j) != "Label")
           {// Переносим следующие записи на освободившееся место.
            ObjectSetText ("ListGlobalGraphicVariable_" + i, ObjectDescription ("ListGlobalGraphicVariable_" + j), 10, "Areal", EMPTY);
            ObjectSetText ("ListGlobalGraphicVariable_" + j, "", 10, "Areal", EMPTY); // Найденную заполненную запись освобождаем.
            break;                                                                    // Выходим из ближайшего цикла.
           }
         }
       }
     }
    // Удаляем последние пустые строки в списке графических переменных.
    for (; ObjectDescription ("ListGlobalGraphicVariable_" + i) == "" || ObjectDescription ("ListGlobalGraphicVariable_" + i) == "Label"; i--) ObjectDelete ("ListGlobalGraphicVariable_" + i);                     // Удаляем часть списка глобальных графических переменных.
    return (AmountDelete); // Завершаем функцию.
   }
  return (-1);
 }
//====================================================================================================================================================
//22. Функция меняет название глобальной графической переменной.======================================================================================
// Возвращает TRUE, если переименование прошло успешно. В противном случае - FALSE.
bool RenamingGlobalChartVariable (string& Name1, // Имя глобальной графической переменной, которое требуется изменить.
                                  string& Name2) // Имя глобальной графической, на которое требуется изменить.
 {
  int i;
  // Создаём новый объект (новую переменную) со свойствами переименнуемого.
  ObjectCreate  (Name2, OBJ_LABEL, 0, 0, 0, 0, 0);
  ObjectSet     (Name2, OBJPROP_TIMEFRAMES, EMPTY);
  ObjectSetText (Name2, ObjectDescription (Name1), 10, "Areal", EMPTY); // Переносим описание на новый объект.
  // Заменяем в списке имя переменной на новое.
  for (i = 0; i < 100; i++) // Цикл по списку глобальных графических переменных.
   {
    if (ObjectDescription ("ListGlobalGraphicVariable_" + i) == Name1)
     {
      ObjectSetText ("ListGlobalGraphicVariable_" + i, Name2, 10, "Areal", EMPTY); // Найденную заполненную запись освобождаем.
      break;
     }
   }
  return (ObjectDelete (Name1)); // Удаляем старую переменную и возвращаем состояние проведённой операции.
 }
//====================================================================================================================================================
//жжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжж